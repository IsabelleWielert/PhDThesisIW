function calib(frames, file, num_input, diam_px, m, n)

load(file, 'tr', 'mat');
%frame ist 1-dim. Feld und dient später beim plotting zur Zuordnung
frame = 0 : (frames - 1);
%Erzeugung und Öffnen des txt-Files 
fid = fopen(txt_file,'w'); 
%Überschrift der txt-Datei:
fprintf(fid, 'Kalibrierung bei binning %1.0f und %4.0f frames\n\n\n', binning, frames);
fprintf(fid, 'Durchmesser der Beads ist: %3.2fµm\n', diam_px*magni);
%Es sollen später die Datenpunkte der Beadzentren in Polarkoordianten
%ausgedrückt werden. Daraufhin soll für einen bestimmten Winkelbereich
%die msd bzw. die Federkonstante bestimmt werden. angle_step ist der Winkelbereich 
%in Grad und angle_steps gibt die Anzahl der benötigten Schritte für einen 
%kompletten Umlauf an 
angle_step = 30;
angle_steps = 360/angle_step;
%msd_angle_corr(:,:) bzw. stiffness_angle(:,:) enthält die msd bzw. die Federkonstante
%für jeden Winkelbereich und jeden Bead  
msd_angle_corr(1:angle_steps,1:num_input) = 0;
stiffness_angle(1:angle_steps,1:num_input) = 0;

%Erste for-Schleife geht von 1 bis Anzahl der Beads; in zweiter Schleife steht j=0 für Kalibrierung
%für x-Werte und j=2 für Kalibrierung der y-Werte
for i=1:num_input;
 for j=1:2;
      %data ist ein 1-dim. array das die x-Werte (j=1) bzw. die y-Werte (j=2)
      %des jeweiligen i.-ten Beads enthält 
      data =  magni*tr(frames*(i-1)+1:frames*i,j)';
      %Driftkorrektur über lineare Regression der Werte
      [lin_fit,errors1] = polyfit(frame, data, 1);
      %slope(j) enthält die jeweilige Steigung
      slope(j) = lin_fit(1);
      %corr enthält die Werte aus data nach Driftkorrektur
      corr = data - slope(j)*frame;
      %Zur Überprüfung der Driftkorrektur wird Steigung der lin. Regression
      %von corr bestimmt und später in txt-File ausgegeben
      [lin_fit_corr, errors2] = polyfit(frame, corr, 1);
      slope_corr(j) = lin_fit_corr(1);
      %mean_xy bestimmt jetzt den genauen Mittelpunkt der Fallen nach
      %Driftkorrektur und data_corr enthält für Berechnung der Abstände r
      %in Polarkoordinaten bzw. für spätere Ermittlung der msd bzw.
      %Federkonstanten die relevanten Daten
      mean_xy(i,j) = mean(corr');
      data_corr(1:frames,j,i) = corr' - mean_xy(i,j);  
      %num ist Nummer des Ausgabefensters für plotting und wird auf frames
      %+ 1 gesetzt damit es keine doppelte Belegung mit Ausgabe der fehlerhaften 
      % frames gibt
      num = frames + i;
      %Es wird für jeden getrackten Bead ein Fenster geöffnet, dass jeweils
      %vier Graphiken enthält: x-Werte gegen frames ohne und mit Driftkorrektur 
      %und y-Werte ohne und mit Driftkorrektur 
      if (j == 1)
         figure(num), subplot(2,2,1), plot( frame, data,'+r'), xlabel('frames'), ylabel('x-Werte [µm]'), ...
         title(['Bead ',int2str(i),': x-Werte ohne Driftkorrektur']), grid on, grid minor;
         hold on
         plot(frame, lin_fit(2) + lin_fit(1)*frame, '-k')
         hold off
         figure(num), subplot(2,2,2), plot(frame, corr, '*r'),xlabel('frames'), ylabel('x-Werte[µm]'), ...
         title(['Bead ',int2str(i),': x-Werte mit Driftkorrektur']), grid on, grid minor;
         hold on
         plot(frame, lin_fit_corr(2) + lin_fit_corr(1)*frame, '-k')
         hold off
      end
      if (j == 2)
         figure(num), subplot(2,2,3), plot(frame, data, '+r'), xlabel('frames'), ylabel('y-Werte[µm]'), ...
         title(['Bead ',int2str(i),': y-Werte ohne Driftkorrektur']), grid on, grid minor;
         hold on
         plot(frame, lin_fit(2) + lin_fit(1)*frame, '-k')
         hold off
         figure(num), subplot(2,2,4), plot(frame, corr, '*r'), xlabel('frames'), ylabel('y-Werte[µm]'), ...
         title(['Bead ',int2str(i),': y-Werte mit Driftkorrektur']), grid on, grid minor;
         hold on
         plot(frame, lin_fit_corr(2) + lin_fit_corr(1)*frame, '-k')
         hold off
         %diese Graphiken werden zudem im Ordner in dem sich auch der Film
         %befindet gespeichert.
         saveas(num, [PathName, 'calib_Bead', int2str(i), '_L', FileName], 'tif')
      end
   end   
 %data_corr(1:frames,3) enthält den Betrag r und data_corr(1:frames,4)
 %den Winkel phi für Polarkoordianten: x = r*cos(phi), y=r*sin(phi).
 data_corr(1:frames,3,i) = sqrt(data_corr(1:frames,1,i).^2 + data_corr(1:frames,2,i).^2);
 for k=1:frames
     if (data_corr(k,1,i)>0 & data_corr(k,2,i)>0)
         data_corr(k,4,i) = atand(data_corr(k,2,i)./data_corr(k,1,i));
     elseif (data_corr(k,1,i)<0 & data_corr(k,2,i)>0)    
         data_corr(k,4,i) = -atand(data_corr(k,2,i)./data_corr(k,1,i)) + 90;
     elseif (data_corr(k,1,i)<0 & data_corr(k,2,i)<0)
         data_corr(k,4,i) = atand(data_corr(k,2,i)./data_corr(k,1,i)) + 180;
     else
         data_corr(k,4,i) = atand(data_corr(k,2,i)./data_corr(k,1,i)) + 360;
     end    
 end
 %Bestimmung der msd_angle_corr (hier in m^2) und der Federkonstanden
 %innerhalb des definierten Winkelbereiches
 for j=1:angle_steps;
    indices = find((data_corr(1:frames,4,i) > angle_step*(j-1)) & (data_corr(1:frames,4,i) <= angle_step*j));
    sz_indices = size(indices);
    frames_angle(j) = sz_indices(1);
    if (frames_angle(j) ~= 0)
        for k=1:frames_angle(j);
            msd_angle_data(k) = data_corr(indices(k), 3, i);
        end    
     msd_angle = (1.0E-6)^2*mean(msd_angle_data.^2);
     %Korrektur der msd_angle aufgrund der Instabilität des Laserfokus mit einer Standardabweichung von 8nm
     msd_angle_corr(j) = msd_angle - (8E-9)^2;
     %Berechnung der Federkonstanten   
     stiffness_angle(j,i) = k_boltzmann*temp/msd_angle_corr(j);   
     msd_angle_data = [];
    end
 end  
 for k = 1:3;
    %Berechnung der msd aus den x- bzw.  y-Werten und den Abständen r: 
    msd = (1.0E-6)^2*mean(data_corr(1:frames,k,i).^2);
    msd_corr(k) = msd - (8E-9)^2;
    stiffness(k) = k_boltzmann*temp/msd_corr(k);   
 end      
 % Schreiben der Daten der Kalibrierung in txt.-File
 fprintf(fid, '\nBead %1.0f (%4.2fµm/%4.2fµm):\n', i, mean_xy(i,1), mean_xy(i,2));
 fprintf(fid, 'Steigung des Drifts in x-Richtung: %+1.10fµm/frame\n', slope(1));
 fprintf(fid, 'Steigung des Drifts in y-Richtung: %+1.10fµm/frame\n', slope(2));
 fprintf(fid, 'Steigung der korrigierten x-Werte: %+1.10fµm/frame\n',slope_corr(1));
 fprintf(fid, 'Steigung der korrigierten y-Werte: %+1.10fµm/frame\n\n', slope_corr(2));
 fprintf(fid, 'Standardabweichung für x-Werte: %3.4fnm\n', (1.0E9)*sqrt(msd_corr(1)));
 fprintf(fid, 'Federkonstante kappa für x-Werte: %2.4fpN/µm\n', (1.0E6)*stiffness(1));
 fprintf(fid, 'Standardabweichung sigma für y-Werte: %2.4fnm\n', (1.0E9)*sqrt(msd_corr(2)));
 fprintf(fid, 'Federkonstante kappa für y-Werte: %2.4fpN/µm\n\n', (1.0E6)*stiffness(2));
 fprintf(fid, 'Standardabweichung für Abstand r: %3.4fnm\n', (1.0E9)*sqrt(msd_corr(3)));
 fprintf(fid, 'Federkonstante kappa: %2.4fpN/µm\n\n', 2*(1.0E6)*stiffness(3));
 fprintf(fid, 'Frames pro Winkelbereich bei Gleichverteilung: %4.2f\n\n', frames/angle_steps);
 fprintf(fid, 'phi[Grad]    frames        StD[nm]    kappa[pN/µm]\n');
 for j=1:angle_steps;
     fprintf(fid, '%3.0f-%3.0f    %4.0f(%+2.1f%%)      %3.4f      %2.4f\n', (j-1)*angle_step, j*angle_step, ...
         frames_angle(j), 100*(frames_angle(j)/(frames/angle_steps)-1), (1.0E9)*sqrt(msd_angle_corr(j)), ...
         2*(1.0E6)*stiffness_angle(j,i));
 end
end
fclose(fid);

for i=1:num_input;
    t = 0:diam_px*magni/200:2*diam_px*magni;
    for j=1:angle_steps;
          figure(2*frames), plot3(t*cosd(angle_step*(j-0.5)) + mean_xy(i,1), ...
                t*sind(angle_step*(j-0.5)) + mean_xy(i,2), (1.0E6)*stiffness_angle(j,i)*t.^2, '-k', 'LineWidth', 2), ...
                zlim([0. 3.]), xlabel('distance in x-direction [µm]'), ylabel('distance in y-direction [µm]'), ...
                zlabel('Pot. Energy [pN*µm]'), title('Potential energy of the optical tweezer'), ...
                grid on, grid minor;
          hold on
    end
    for k=1:10
        z(1:angle_steps + 1) = 5/10*k; 
      for j=1:angle_steps;
        x_plot_data(j) = sqrt(z(1)/((1.0E6)*stiffness_angle(j,i)))*cosd(angle_step*(j-0.5)) + mean_xy(i,1);
        y_plot_data(j) = sqrt(z(1)/((1.0E6)*stiffness_angle(j,i)))*sind(angle_step*(j-0.5)) + mean_xy(i,2);
      end  
      x_plot_data(angle_steps + 1) = sqrt(z(1)/((1.0E6)*stiffness_angle(1,i)))*cosd(angle_step*0.5) + mean_xy(i,1);
      y_plot_data(angle_steps + 1) = sqrt(z(1)/((1.0E6)*stiffness_angle(1,i)))*sind(angle_step*0.5) + mean_xy(i,2);
      plot3(x_plot_data, y_plot_data, z, '-r', 'LineWidth', 2);
      hold on
    end  
end
hold off
saveas(2*frames, [PathName, 'potential_angle_L', FileName], 'tif');
%Ausgabe der 2-dim. Verteilung der Beadzentren und Ausgabe der Potentiale der
%optischen Fallen:

%bin ist Vergrößerungsfaktor, d.h. es stehen zur Bestimmung der subpixel
%genauen Beadzentren "bin" mal so viele Pixel zu Verfügung
bin = 12;
%distr ist ein 2-dim. (bin*m,bin*n)-array, dass später graphisch dargestellt werden soll, wobei jedes Element des
%arrays für einen Pixel steht und diese Elemente zuert auf Null gesetzt
%werden. Später werden die Beadzentren gezählt, die in ein solchen
%Pixelfeld fallen.
distr(1:bin*m,1:bin*n) = 0;
for i=1:num_input;
  %Folgende Schleife geht alle frames durch, betrachtet jeden x- bzw. y-Wert und bestimmt mit dem floor-Befehl
  %die jeweiligen Indizes für das distr-Feld
  for k=1:frames;
      find_bm = floor(bin/magni*(data_corr(k,2,i) + mean_xy(i,2))) + 1;
      find_bn = floor(bin/magni*(data_corr(k,1,i) + mean_xy(i,1))) + 1;
      distr(find_bm, find_bn) = distr(find_bm, find_bn) + 1;
  end
end
%potential ist proportional zum wahren Potential U(x)=-k_b*T*exp(P(x)), wobei P(x) die Wahrschinlichkeit darstellt
%den Bead am Ort x anzutreffen. Einheit: pN*µm
potential = -(1.0E18)*k_boltzmann*temp*log((distr + 1)/frames);
%Folgende for-Schleife ist für die Ausgabe zuständig.
for i=1:num_input;
  %Folgende vier Zeilen sind zur Bestimmung der Ausgabebereiche wichtig. Es wird für jeden Bead vom Mittelwert mean_corr_xy
  %ausgegangen und der Bereich um den Mittelwert mit 3fachen Beaddurchmesser berechnet    
  sz_min_m = round(bin*mean_xy(i,2)/magni - 1.5*diam_px);
  sz_max_m = round(bin*mean_xy(i,2)/magni + 1.5*diam_px);
  sz_min_n = round(bin*mean_xy(i,1)/magni - 1.5*diam_px);
  sz_max_n = round(bin*mean_xy(i,1)/magni + 1.5*diam_px);
  x_i = magni/bin*(1:(sz_max_m - sz_min_m + 1));
  y_i = magni/bin*(1:(sz_max_n - sz_min_n + 1));

  %Ausgabe der 2-dim. Verteilung für i-ten Bead
  figure(num+i), colormap(jet), 
  imagesc(distr(sz_min_m:sz_max_m, sz_min_n:sz_max_n)), colorbar;
  %Speicherung der 2-dim. Verteilung für i-ten Bead
  saveas(num + i, [PathName, 'distribution_bead', int2str(i), '_L', FileName], 'tif');
  %Ausgabe des 3-dim. Fallenpotentials
  figure(num + num_input + i),
  meshc(x_i, y_i, potential(sz_min_m:sz_max_m, sz_min_n:sz_max_n)), zlabel('Potential Energy [pN*µm]') %
  shading interp
  colormap(jet), colorbar, axis on;
  %Speicherung des 3-dim. Fallenpotentials für i-te Falle
  saveas(num + num_input + i, [PathName, 'potential_bead', int2str(i),'_L', FileName], 'tif');
end
end